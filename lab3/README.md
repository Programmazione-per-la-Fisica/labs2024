<!-- markdownlint-disable-file MD028 -->
# Laboratorio 3

In questa lezione inizieremo ad apprendere come utilizzare i meccanismi di astrazione del _C++_ costruendo semplici
classi e strutture.

---

- [Laboratorio 3](#laboratorio-3)
  - [Area di lavoro](#area-di-lavoro)
  - [Retta di regressione](#retta-di-regressione)
    - [Definizione dei test per la classe `Regression`](#definizione-dei-test-per-la-classe-regression)
    - [Implementazione della classe `Regression`](#implementazione-della-classe-regression)
    - [Identificazione dei metodi _const_](#identificazione-dei-metodi-const)
    - [Aggiungere altri test](#aggiungere-altri-test)
    - [Utilizzo di `SUBCASE`](#utilizzo-di-subcase)
    - [Soluzione](#soluzione)
  - [Consegna obbligatoria del lavoro svolto](#consegna-obbligatoria-del-lavoro-svolto)
  - [Approfondimenti e esercizi](#approfondimenti-e-esercizi)

---

L'obiettivo principale di questo laboratorio è imparare i rudimenti dell'uso di `class` e `struct`.

Per farlo, realizzeremo una `class` (`Regression`) che, una volta inserita una serie di punti nel piano cartesiano,
permetta di calcolare pendenza e intercetta della
[retta di regressione](https://it.wikipedia.org/wiki/Regressione_lineare),
le quali verranno memorizzate in una `struct` (`Result`).

Durante il laboratorio vi invitiamo a tenere aperte le
[slide](https://github.com/Programmazione-per-la-Fisica/pf2024/releases/latest) presentate a lezione.

## Area di lavoro

Creiamo una nuova directory di lavoro (ad esempio `pf_labs/lab3`) e aggiungiamo il file `.clang-format`. Possiamo
copiarlo dalla cartella utilizzata per il primo laboratorio, o generarlo ex-novo.

> [!TIP]
> Ad esempio, potete procedere in modo analogo a quanto fatto [qui](../lab1/README.md#area-di-lavoro).

In seguito scarichiamo il file
[`doctest.h`](https://raw.githubusercontent.com/doctest/doctest/master/doctest/doctest.h)
tramite il seguente comando:

```bash
$ pwd
/home/battilan/pf_labs/lab3
$ curl https://raw.githubusercontent.com/doctest/doctest/master/doctest/doctest.h -o doctest.h
```

> [!TIP]
> Verificate che il file `doctest.h` sia stato scaricato correttamente.
>
> Per farlo, potete verificare che l'output del comando `head` sia analogo a quello mostrato qui:
>
> ```bash
> $ head -20 doctest.h
> // ====================================================================== lgtm [cpp/missing-header-guard]
> // == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==
> // ======================================================================
> //
> // doctest.h - the lightest feature-rich C++ single-header testing framework for unit tests and TDD
> //
> // Copyright (c) 2016-2023 Viktor Kirilov
> //
> // Distributed under the MIT Software License
> // See accompanying file LICENSE.txt or copy at
> // https://opensource.org/licenses/MIT
> //
> // The documentation can be found at the library's page:
> // https://github.com/doctest/doctest/blob/master/doc/markdown/readme.md
> ...
> ```

Fatto ciò, l'area di lavoro deve trovarsi in questo stato:

```bash
$ pwd
/home/battilan/pf_labs/lab3
$ ls -A
.clang-format  doctest.h
```

## Retta di regressione

Dato un insieme di $N$ punti nel piano cartesiano, ciascuno rappresentato dalla coppia di coordinate $(x_i, y_i)$, i
coefficienti della retta di regressione $y = A + B \cdot x$ sono ricavabili tramite le seguenti formule:

$$ A = \frac {\sum y_{i} \sum x_{i}^{2} - \sum x_{i} \sum x_{i} y_{i}}{N \sum x_{i}^{2} - (\sum x_{i})^{2}} $$

$$ B = \frac {N \sum x_{i}y_{i} - \sum x_{i} \sum y_{i}}{N \sum x_{i}^{2} - (\sum x_{i})^{2}} $$

Quello che vogliamo fare è implementare in _C++_ uno strumento che calcoli questi valori, costruendo una classe
`Regression` che permetta di gestire l'inserimento delle coordinate dei punti $(x_i, y_i)$ e restituisca la coppia di
valori $A$, e $B$, nascondendo i dettagli implementativi relativi alle formule utilizzate.

Inoltre vogliamo raggruppare tali risultati in un'unica _struttura dati_: `Result`.

### Definizione dei test per la classe `Regression`

Per risolvere il problema tramite l'uso di una classe, è opportuno cominciare identificando le _funzionalità minime_
che questa deve garantire, così come _l'interfaccia_ che questa esporrà a un eventuale utilizzatore.

Nel nostro caso serviranno:

- un metodo `add` per inserire nuovi punti espressi come coordinate $(x, y)$ (aggiunti, per ora, uno alla volta);
- un metodo `fit` che ritorni i coefficienti `A` e `B` della retta di regressione (calcolati utilizzando i punti
  inseriti fino ad un dato momento).

Anche in questo caso, una buona prassi è quella di cominciare **implementando alcuni test**. Apriamo quindi VSCode
nell'area di lavoro:

```bash
$ pwd
/home/battilan/pf_labs/lab3
$ code .
```

creiamo un nuovo file (es: `regression.cpp`) e inseriamo il frammento di codice proposto sotto, il quale:

- aggiunge una coppia di punti di coordinate $(x_1, y_1) = (0.,1.)$ e $(x_2, y_2) = (1.,2.)$;
- calcola e verifica i risultati (in questo caso banali) della regressione.

```c++
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h"

TEST_CASE("Testing the class handling linear regression") {
  Regression reg;
  reg.add(0., 1.);
  reg.add(1., 2.);
  auto result = reg.fit();
  CHECK(result.A == doctest::Approx(1.));
  CHECK(result.B == doctest::Approx(1.));
}
```

> [!IMPORTANT]
> Se non lo state già facendo vi consigliamo di utilizzare la combinazione di
> [tasti di scelta rapida](https://code.visualstudio.com/docs/getstarted/keybindings#_keyboard-shortcuts-editor)
> associata alla creazione di un file vuoto in VSCode e, d'ora in poi, abituarvi a farlo con regolarità.

> [!IMPORTANT]
> Dato che confrontiamo numeri _floating-point_, possiamo usare `Approx`, in modo da tollerare eventuali errori di
> arrotondamento.

Proviamo a compilare il programma, e verifichiamo attentamente i messaggi d'errore riportati.

> Su Linux/WSL:
>
> ```bash
> g++ regression.cpp -Wall -Wextra -o regression
> ```
>
> o, su macOS:
>
> ```bash
> g++-14 regression.cpp -Wall -Wextra -o regression
> ```

Quello che notiamo è che il compilatore riporta un errore relativo all’assenza della classe `Regression`, che non è
ancora stata implementata.

### Implementazione della classe `Regression`

Procediamo quindi a creare la classe `Regression`, aggiungendo quanto segue al file `regression.cpp`  **prima** del
`TEST_CASE`:

```c++
...

class Regression {
};

TEST_CASE("Testing the class handling linear regression") {
...
}
```

Ripetendo la compilazione (verificate!) otteniamo errori (diversi da prima) legati alla mancanza dei metodi `add` e
`fit`.

Ovviare alla mancanza di `add` è facile, basta aggiungerlo alla classe:

```c++
class Regression
{
 public:
  void add(double x, double y) {}
};
```

> [!IMPORTANT]  
> **Notiamo che, in `add`**:
>
> - il _return type_ è `void`, in quanto il metodo non deve restituire nulla;
> - i due argomenti sono entrambi di tipo `double`;
> - l'implementazione per ora non fa nulla; il comportamento è naturalmente sbagliato, ma ci permette di iniziare a
>   definire l'interfaccia e risolve l'errore di compilazione;
> - il fatto che non stiamo ancora utilizzando le variabili `x` e `y` nell'implementazione di `add` genera dei _warning_
>   (avvertimenti) in fase di compilazione (verificatelo).

Aggiungere il metodo `fit` richiede maggiore attenzione, perché dobbiamo prima definire il tipo ritornato.

Dall’uso che viene fatto dell’oggetto `result` nel `TEST_CASE`, vediamo che deve avere due dati membri pubblici,
chiamati `A` e `B`, entrambi di tipo `double`.
Procediamo quindi definendo la `struct` `Result`, in modo che includa quei campi.

In _C++_ il tutto si traduce in:

```c++
...
struct Result
{
  double A;
  double B;
};

class Regression
{
 public:
  void add(double x, double y) {}
  auto fit()
  {
    return Result{};
  }
};
...
```

> [!IMPORTANT]  
> **Notiamo che `fit`**:
>
> - non ha argomenti;
> - per ora la sua implementazione restituisce una `struct` `Result` con i campi inizializzati (ci preoccuperemo di
>   implementare correttamente la logica della regressione tra poco).

Con queste modifiche il programma compila correttamente (provate!), **ma fallisce tutti i test**.

Pensiamo quindi a come implementare i due metodi, così che **facciano quello che vogliamo**.

Nel caso dell'implementazione di una classe come questa, la cosa spesso implica chiedersi: _cosa abbiamo bisogno di memorizzare, in termini di variabili membro (private) della classe, per raggiungere i nostri scopi?_

> [!TIP]  
> Nel nostro caso, la domanda sopra si traduce in questa: _ci serve davvero mantenere in memoria tutti i punti inseriti
> tramite il metodo `add`, per un loro utilizzo quando viene chiamato il metodo `fit`, o ci sono alternative?_

Se si osservano attentamente le formule indicate sopra, si può notare che non c'è bisogno di farlo, ma è sufficiente
mantenere alcuni _accumulatori_ di valori:

- $N$
- $\sum x_i$
- $\sum y_i$
- $\sum x_i^2$
- $\sum x_i y_i$

che possiamo aggiornare man mano che viene chiamato il metodo `add`.

Questi valori verranno poi opportunamente combinati nel momento in cui viene chiamato il metodo `fit` per calcolare il
risultato.

Come si implementa questa idea in _C++_?

```c++
class Regression
{
  int N_{0};
  double sum_x_{0.};
  double sum_y_{0.};
  ...

 public:
  void add(double x, double y)
  {
    ++N_;
    sum_x_ += x;
    sum_y_ += y;
    ...
  }

  auto fit()
  {
    double const a = ...
    double const b = ...
    return Result{a, b};
  }
}
```

> [!NOTE]
> Completate il codice dove trovate `...`

> [!IMPORTANT]
> Tipicamente, si utilizzando criteri per distinguere le variabili membro di una classe da quelle definite nello
> _scope_ di una determinata funzione membro. Nel caso sopra, abbiamo introdotto un "_" alla fine del nome della
> variabile (es.: `N_`).

> [!NOTE]
> Le variabili membro sono costituite da tipi primitivi, quindi devono essere inizializzate, altrimenti il loro valore
> iniziale risulta indeterminato. Qui proponiamo di inizializzarle direttamente dove sono dichiarate, usando la sintassi
> `{0.}` e `{0}`. In questo modo i valori sono "inizializzati a zero".
> In alternativa si potrebbe:
>
> - usare la sintassi più esplicita `int n = 0;`, `double sum_x = 0.;`, etc ...;
> - definire esplicitamente un costruttore di default, che nella sua  _initialization-list_ inizializzi tutti i valori
>   a zero.
>
> Se vi rimane tempo potete provare a sperimentare tutte le alternative.

Se l'implementazione è corretta, entrambi i test devono essere eseguiti con successo.

### Identificazione dei metodi _const_

Facciamo un'ultima modifica al codice della classe, dichiarando `fit` come `const` in quanto **non modifica** i dati
membri.

```c++
class Regression
{
  // ...
  auto fit() const
  {
    // ...
  }
  // ...
};
```

> [!IMPORTANT]
> In generale, è **fondamentale** specificare come tali tutti i metodi della nostra classe che ci aspettiamo debbano
> essere `const`.
>
> Contrariamente ai tipi primitivi, dove le azioni possibili (la lettura o la modifica del valore in essi contenuto)
> sono evidentemente collegate al concetto di _constness_, nel caso di una classe può non risultare ovvio se ci si
> aspetta che un metodo vada o meno a modificarne i dati membro.
>
> Notate che:
>
> - una volta create istanze `const` di una determinata classe, esse possono invocare solo funzioni membro `const`;
> - un dato membro della classe non può essere modificato all'interno di un metodo `const`;
>
> qualora tentassimo per errore di violare queste regole, il compilatore segnalerebbe l'inconsistenza, **proteggendoci**
> dallo scrivere codice concettualmente inconsistente.

Per verificare l'effetto dell'uso dell'identificatore `const` provate ad aggiungere la seguente funzione libera prima dei `TEST_CASE`:

```c++
auto fit(Regression const& regression) {
  return regression.fit();
}
```

e a compilare il programma includendo e rimuovendo l'identificatore `const` nella dichiarazione di `fit`
all'interno della classe `Regression`.

### Aggiungere altri test

Ora che la classe `Regression` è implementata e soddisfa il nostro test minimale, è opportuno aggiungere altri casi di
test.

Ricordiamo che l'obiettivo dei test non è di confermare che il programma funzioni; al contrario, l'obiettivo è di
**rompere** il codice. Cercare attivamente potenziali "punti deboli" dal principio ci permette di evidenziare e
risolvere problemi sin da subito.

> [!IMPORTANT]
> I test definiti in questo momento andranno **ripetutamente eseguiti dopo ogni nuova modifica**, ciò permetterà di
> verificare che nuovi problemi non appaiano durante lo sviluppo.

A titolo esemplificativo, cosa vorremmo che succedesse se:

- chiamiamo `fit` senza aggiungere alcun punto?
- chiamiamo `fit` dopo aver aggiunto un solo punto?
- chiamiamo `fit` dopo aver aggiunto due punti uguali?
- chiamiamo `fit` dopo aver aggiunto due punti allineati verticalmente (cioè con
  la stessa $x$)?

> [!TIP]
> Per verificare se la retta ha pendenza verticale, possiamo sfruttare il fatto che, in questo caso, esiste una
> relazione ben definita tra $\sum x_i$ e $\sum x_i^2$, quale?

> [!NOTE]
> Per gestire in modo appropriato comportamento del metodo `fit` nei casi sopra citati, possiamo avvalerci di
> _exception_.

> [!IMPORTANT]
> Ricordatevi che, qualora venga sollevata una exception all'interno di una funzione, il flusso _normale_ di esecuzione
> del programma viene alterato, pertanto non si giungerà alla parte della funzione dove questa fa il `return`
> dell'eventuale risultato atteso.
>
> Inoltre, quando si utilizza `doctest`, il modo corretto di verificare se viene
> fatto correttamente il `throw` di una exception è quello di utilizzare una
> sintassi analoga a:
>
> ```c++
> CHECK_THROWS(regression.fit());
> ```
>
> Per ulteriori dettagli rimandiamo alla sezione
> [Exceptions](https://github.com/doctest/doctest/blob/master/doc/markdown/assertions.md#exceptions)
> della documentazione `doctest`.

Inoltre vi consigliamo di aggiungere alcuni test che utilizzano tre o più punti, possibilmente non allineati, e inserire
nei `CHECK` i valori attesi di `A` e `B`.

I calcoli:

- si possono fare con carta e penna;
- si possono fare utilizzando [WolframAlpha](https://www.wolframalpha.com);
- possono essere validati usando i dati raccolti durante le prove del corso di _Laboratorio di Meccanica e
  Termodinamica_ e i relativi risultati.

### Utilizzo di `SUBCASE`

Quando si implementano più test, specialmente se sono relativi a un'unica classe o a un insieme di funzionalità tra loro
collegate, è possibile esprimerli utilizzando i `SUBCASE`, così da partire sempre dalle stesse condizioni iniziali.

Provate ad utilizzare i `SUBCASE` nel caso del programma implementato oggi.

> [!NOTE]
> Per una comprensione più dettagliata dei `SUBCASE`, potete consultare la
> [documentazione](https://github.com/doctest/doctest/blob/master/doc/markdown/tutorial.md#test-cases-and-subcases).

### Soluzione

Come menzionato durante la lezione di ieri, la soluzione dell'esercizio proposto sarà discussa in classe all'inizio del
secondo ciclo di lezioni.

## Consegna obbligatoria del lavoro svolto

Pertanto, la consegna dell'elaborato relativo al lavoro svolto per questo laboratorio è, in via eccezionale,
**obbligatoria**.

A coloro che non hanno terminato l'intera traccia (inclusa l'aggiunta di ulteriori test e l'uso di `SUBCASE`), chiediamo
di completare il lavoro in autonomia a casa.

Le consegne **non verranno valutate** e **NON contribuiscono al risultato dell'esame**.

Premesso ciò:

- vi ricordiamo che l'aver **raggiunto un livello minimo di padronanza** con gli **argomenti trattati nei primi tre
  laboratori** risulta indispensabile per **seguire con profitto le lezioni del secondo ciclo**;
- vi anticipiamo che la traccia del **quarto laboratorio tratterà di ulteriori sviluppi della classe `Regression`**,
  il cui completamento risulta quindi necessario.

La consegna deve avvenire, da parte dei singoli studenti, tramite
[questo link](https://virtuale.unibo.it/mod/assign/view.php?id=1652613), il quale prevede il solo caricamento di file
`.zip` o `.tgz`.

Supponendo che tutto il materiale sia nella cartella `lab3` (e supponendo di trovarsi in tale cartella), per creare un
archivio `.zip` procedere come segue:

```bash
$ pwd
/home/battilan/pf_labs/lab3
$ cd ..
$ zip -r lab3.zip lab3
$ ls
lab3 lab3.zip
```

Per creare un archivio `.tgz` procedere invece come segue:

```bash
$ pwd
/home/battilan/pf_labs/lab3
$ cd ..
$ tar czvf lab3.tgz lab3
$ ls
lab3 lab3.tgz
```

## Approfondimenti e esercizi

Riportiamo qui un possibile esercizio alternativo che potete risolvere utilizzando `class` e `struct` e un approccio
simile a quello che abbiamo imparato oggi.

Si tratta del
[terzo laboratorio proposto per questo corso durante l'A.A. 2023/2024](https://github.com/Programmazione-per-la-Fisica/labs2023/blob/main/lab3/README.md),
che riguarda lo sviluppo di una classe che calcoli alcune statistiche (es.: media, deviazione standard, etc) a partire
da un campione di dati inserito utilizzando un metodo `add`.

Il nostro suggerimento è di leggere solo la parte iniziale relativa alla descrizione del compito e la presentazione
delle equazioni risolutive, per poi affidarvi alla traccia "il meno possibile" e pensare da soli a come implementare la
classe `Sample`  i relativi test.
